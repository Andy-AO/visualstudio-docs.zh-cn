---
title: C6279
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- C6279
helpviewer_keywords:
- C6279
ms.assetid: 0af88b58-35df-456f-8c02-e8eeffe3b7de
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: 6138c453ad66415b1127b249d568432bf2f4710d
ms.sourcegitcommit: 5f6ad1cefbcd3d531ce587ad30e684684f4c4d44
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/22/2019
ms.locfileid: "72746517"
---
# <a name="c6279"></a>C6279
警告 C6279： \<variable > 是用标量 new 分配的，已删除数组 delete []

此警告仅出现在C++代码中，指示调用函数具有不一致的带标量**new**运算符分配的内存，但用数组**delete []** 运算符释放了该函数。 如果内存是用标量**new**分配的，则通常应通过标量**delete**来释放内存。

至少有三个原因可能导致问题：

- 即使析构函数是，也不会调用数组中各个对象的构造函数。

- 如果全局（或特定于类的）**运算符 new**和**operator delete**与**operator new []** 和**operator delete []** 不兼容，则很可能会发生意外的结果。

此缺陷的确切后果很难预测。 由于未调用构造函数，因此它可能会导致随机行为或因使用未初始化的内存而崩溃。 或者，它可能会导致内存分配，并在重写运算符的情况下崩溃。 在极少数情况下，不匹配可能并不重要。 分析工具当前不区分这两种情况。

## <a name="example"></a>示例

下面的代码将生成此警告：

```cpp
class A
{
  // members
};

void f ( )
{
  A *pA = new A;
  //code ...
  delete[] pA;
}
```

若要更正此警告，请使用以下代码：

```cpp
void f( )
{
  A *pA = new A;
  //code ...
  delete pA;
}
```

若要完全避免这些分配问题，请使用 C++ 标准模板库 (STL) 提供的机制。 其中包括[shared_ptr](/cpp/standard-library/shared-ptr-class)、 [unique_ptr](/cpp/standard-library/unique-ptr-class)和[矢量](/cpp/standard-library/vector)。 有关详细信息，请参阅[智能指针](/cpp/cpp/smart-pointers-modern-cpp)和[ C++标准库](/cpp/standard-library/cpp-standard-library-reference)。

## <a name="see-also"></a>请参阅

- [C6014](../code-quality/c6014.md)
