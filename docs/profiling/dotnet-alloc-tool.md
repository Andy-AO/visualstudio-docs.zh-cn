---
title: 分析 .NET 对象的内存使用情况 | Microsoft Docs
ms.date: 12/9/2019
ms.topic: conceptual
helpviewer_keywords:
- memory allocation, memory usage
author: Sagar-S-S
ms.author: sashe
manager: AndSter
ms.workload:
- multiple
ms.openlocfilehash: 9518ffd618a6d82505feca33b37b5151a3a9f961
ms.sourcegitcommit: aa302af53de342e75793bd05b10325939dc69b53
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 01/11/2020
ms.locfileid: "75886760"
---
# <a name="analyze-memory-usage-using-the-net-object-allocation-tool"></a>使用 .NET 对象分配工具分析内存使用情况

通过 .NET 对象分配工具，可查看应用使用了多少内存，以及哪些代码路径分配了最多的内存。

运行该工具后，可查看在其中分配对象的函数执行路径，这样便可追溯到占用最大内存量的调用树的根路径。

## <a name="setup"></a>安装

1. 在 Visual Studio 中打开性能探查器 (Alt + F2)  。
2.  选中“.NET 对象分配跟踪”复选框  。

![诊断中心](../profiling/media/diaghub.png "诊断中心")

> [!NOTE]
> 启动项目被默认选为“分析目标”，但可打开“更改目标”下拉菜单，然后从可用选项中进行选择，将其更改为正在运行的进程、可执行文件、正在运行的应用和已安装的应用   。

   .NET 对象分配工具当前不支持通过下拉菜单选择可执行文件。 你将必须通过 exe 项目系统才能使用该工具。 要执行此操作，请关闭当前解决方案（“文件” -> “关闭解决方案”），然后点击“文件” -> “打开项目或解决方案”-> 选择你的 .exe 文件     。

![分析目标](../profiling/media/analysistarget.png "分析目标")

3. 单击“启动”按钮，运行该工具  。

![停止收集](../profiling/media/stopcollection.png "停止收集")

4. 工具开始运行后，在应用中浏览所需方案，然后按“停止收集”或关闭应用以查看数据  。
5. 单击“分配”选项卡，你应可看到如下所示的图像  。

Allocation![](../profiling/media/allocation.png "分配")

恭喜！ 你现可分析对象的内存分配情况了。

## <a name="understand-your-data"></a>了解数据

### <a name="collection"></a>集合

![集合](../profiling/media/collection.png "集合")

通过“集合”视图，可查看垃圾回收过程中收集的对象数以及保留的对象数。 此视图还提供了几个饼图，可按类型直观显示收集的对象和保留的对象。

- “已收集”列显示了垃圾回收器收集的对象数  。
- “已保留”列显示了运行垃圾回收器后保留的对象数  。

### <a name="allocation"></a>分配

![分配已展开](../profiling/media/allocationexpanded.png "分配已展开")

通过“分配”视图，可查看正在分配内存的对象的位置，以及这些对象分配的内存量。

- “名称”列是占用内存的各种类和结构的列表  。 如果该类别中有占用内存的项，则该列中的每个项都是一个可展开的节点。 （仅限“分配”视图  ）
- “总计(分配)”列显示了特定分配类型中占用内存的对象数  。 （“分配”、“调用树”和“函数”视图    ）
- “自身(分配)”列显示了单个项中占用内存的对象数  。 （“分配”、“调用树”和“函数”视图    ）
- 这三列均可排序。 对于“名称”列，按字母顺序对项进行排序（向前或向后）  。 对于“总计”和“自身(分配)”，可按数字对项进行排序（递增或递减）   。
- 默认情况下，不启用“总大小(字节)”和“自大小(字节)”列   。 要启用它们，请右键单击“名称”、“总计”或“自身(分配)”列，然后单击“总大小”和“自大小”选项，将它们添加到图表中      。 这两列与“总计(分配)”和“自身(分配)”很相似，只是它们不显示占用内存的对象数，而是显示这些对象占用的内存总量（以字节为单位）   。 [仅限“分配”视图]

### <a name="call-tree"></a>调用树

![调用树](../profiling/media/calltree.png "调用树")

通过“调用树”视图，可查看包含分配大量内存的对象的函数执行路径  。

- “函数名”列显示了函数的进程或名称，该函数包含根据你正在检查的节点级别分配内存的对象  。
- “总计”和“自身(分配)”列与“分配”视图显示的信息相同    。
- “模块名”列显示了包含正在调用的函数或进程的模块  。

![热路径](../profiling/media/hotpath.png "热路径")

- “展开热路径”按钮突出显示一个函数执行路径，该路径包含许多正在分配内存的对象  。 该算法从用户选定的感兴趣节点开始，突出显示大多数分配的路径，从而指导用户进行调查。
- “显示热路径”按钮可打开或关闭火焰图标，这些图标指示哪个节点是“热路径”的一部分   。

### <a name="functions"></a>函数

![函数](../profiling/media/functions.png "函数")

“函数”视图显示了正在分配内存的进程、模块和函数  。

- “名称”列将进程显示为最高级别的节点  。 模块在进程下面，函数在模块下面。
- “总计”和“自身(分配)”列与“分配”视图显示的信息相同    。

“分配”、“调用树”和“函数”视图都包含[显示“仅我的代码”]、“显示本机代码”和“搜索”选项       ：

![筛选器栏](../profiling/media/filterbar.png "筛选器栏")

- [显示“仅我的代码”]会折叠系统、框架和其他非用户代码，并将其转换为“[外部代码]”框架，以便用户代码能够得到重点关注   。 有关详细信息，请参阅[使用“仅我的代码”调试用户代码](../debugger/just-my-code.md)。
- “显示本机代码”显示了分析目标中的本机代码，包括非用户代码（如选中）  。
- 通过“筛选器”框，可根据提供的参数筛选“名称”或“函数名”列    。 只需在字段中键入内容，表就会向下筛选，仅显示包含所提供的字符串的类型。
